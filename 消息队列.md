## RabbitMq

RabbitMq是消息队列的一种，还有kafka、rocketMq等等后续都会介绍到。

消息队列是什么？能用来干啥？

RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。

RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。

PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。

### 系统架构图

![image-20241017162439349](D:\TXT\图片文件\image-20241017162439349.png)

相关概念：

生产者和消费者

1. 生产者：邮件发送者（生产消息的人）
2. 消费者：邮件接收者（接收消息的人）

消息一般由 2 部分组成：**消息头**（或者说是标签 Label）和 **消息体**。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。

交换器

![image-20241017164053248](D:\TXT\图片文件\image-20241017164053248.png)

交换器就是将生产者产生的消息分配到对应的队列中（Queue），生产者向交换器发送消息时会给定一个RoutingKey。交换器和队列通过BindingKey绑定，当消息到达交换器后，RoutingKey和BindingKey匹配成功后将相关的消息存入相应的队列中（一个消息可以被发送到多个队列中），等待消费者使用。

**RabbitMQ** 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。

**Broker**：消息中间件的服务节点

broker可以看做是RabbitMq的服务节点，一般称broker为一个RabbitMq服务器

![image-20241017173340969](D:\TXT\图片文件\image-20241017173340969.png)

**交换类型：**

fanout: 只要是到达交换器的消息，都会转发到与交换器绑定的队列中，规则简单，速度快，适合用来广播消息

direct：相比fanout来说非常严格，只有RoutingKey和BindingKey完全匹配才会被转发到响应的队列中，direct通常用来处理优先级任务，通过指定的键将优先级高的消息发送到指定队列

topic：灵活性很高，如果我们的RoutingKey是用 `.`号分隔的字符串，例如`com.stu.abc`，那么在交换器中可以指定响应的规则：`*`表示只匹配一位的通配符，`#`，可以匹配0个或者多个位(这里所说的位是被`.`分隔出来的，就像上面所给出的字符串，com就是表示可以通配的一位。com.*.abc表示转发com开头 abc结尾的消息到指定队列，com.# 表示抓发以com开头的所有消息到指定队列)

header：headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ 会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。

**消息转换器**

在发送和接收消息时，可能有些数据用jdk自带的转换器会导致信息大小变大、可读性变差。所以可以自己定义一个消息转换器，从而提高消息的可读性和降低消息大小。

> 声明一个消息转换器的bean
>
> ```java
>  @Bean
>     public MessageConverter Jackson2JsonMessageConverter(){
>         return new Jackson2JsonMessageConverter();
>     }
> ```
>
> 

**消息可靠性**

生产者重连（仅仅是连接失败时的重试，并不是发送消息失败的重试）

mq有一个连接失败重试机制，默认是关闭的。但是这个失败重连机制是阻塞式的，可能会对业务造成影响。要么就关闭重试机制，要么就设置合理的重试时间，并异步的来发送消息，这样就降低了对后续业务的影响。

![image-20241222162524427](D:\TXT\图片文件\image-20241222162524427.png)

《在yml配置文件中匹配》



生产者确认

mq实现了publisher confirm 和 ppublisher return 两种确认机制，确认机制开启后，在MQ成功收到消息后会返回消息给生产者，返回的结果有以下几种情况：

- 消息到达了MQ，但是路由失败，此时会通过Publisher Return 返回路由异常原因，然后返回路由异常原因，然后返回ACK，告知投递成功。
- 消息到达MQ并成功入队，返回ACK，告知消息接收成功。
- 消息到达MQ，入队并完成持久化，返回ack，告知消息接收成功。
- 其他情况均返回NACK 表示消息未投递成功。

![image-20241222163832631](D:\TXT\图片文件\image-20241222163832631.png)



**注意：**生产者确认机制会造成额外网络开销，如果一定要使用那么建议关闭publisher-return机制，因为一般项目中不会出现这种问题（通常是消息没发送到交换机或队列没接收到消息导致）通常是业务代码中的问题。





MQ数据持久化：

因为MQ默认将消息保存在内存中，提高收发效率，但是它通常会导致一些问题：

- mq宕机导致消息丢失

- 内存空间有限，当消息处理慢时，会造成消息堆积，占用大量内存空间，引发mq阻塞

  > 消息增多时会产生pageOut（将内存中的消息写入磁盘盘中，在写入磁盘这一过程中会引发mq阻塞，导致mq接收消息的速度急速下降到零。



Lazy Queue：

3.6 版本后增加的新模式	在3.12版本后队列默认使用惰性队列

持久化时应将mq的交换机，队列和消息都持久化，这样来保证数据的可靠性。





**消费者可靠性**

消费者确认机制，当消费者接收处理消息后应当给mq一个回调，有以下三种值：

- ack：消息处理成功，返回ack，mq将消息删除
- unacked：消息处理时出现异常处理处理失败，mq重新发送消息给消费者
- reject：消息处理失败并拒绝该消息，mq直接删除该消息



![image-20241222224517517](D:\TXT\图片文件\image-20241222224517517.png)



springAMQP已经实现了消息确认机制，并可以通过配置文件的方式来选择ACK处理方式，如下：

- none：不处理，当消费者收到消息后，mq立马删除消息。
- manual：手动处理，通过代码来选择ack或reject，存在业务入侵，但是这种方式更加灵活
- auto：自动处理
  - 业务异常会返回unack
  - 消息处理或校验异常则会返回reject
