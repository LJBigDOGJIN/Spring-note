## RabbitMq

RabbitMq是消息队列的一种，还有kafka、rocketMq等等后续都会介绍到。

消息队列是什么？能用来干啥？

RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。

RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。

PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。

### 系统架构图

![image-20241017162439349](D:\TXT\图片文件\image-20241017162439349.png)

相关概念：

生产者和消费者

1. 生产者：邮件发送者（生产消息的人）
2. 消费者：邮件接收者（接收消息的人）

消息一般由 2 部分组成：**消息头**（或者说是标签 Label）和 **消息体**。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。

交换器

![image-20241017164053248](D:\TXT\图片文件\image-20241017164053248.png)

交换器就是将生产者产生的消息分配到对应的队列中（Queue），生产者向交换器发送消息时会给定一个RoutingKey。交换器和队列通过BindingKey绑定，当消息到达交换器后，RoutingKey和BindingKey匹配成功后将相关的消息存入相应的队列中（一个消息可以被发送到多个队列中），等待消费者使用。

**RabbitMQ** 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。

**Broker**：消息中间件的服务节点

broker可以看做是RabbitMq的服务节点，一般称broker为一个RabbitMq服务器

![image-20241017173340969](D:\TXT\图片文件\image-20241017173340969.png)

**交换类型：**

fanout: 只要是到达交换器的消息，都会转发到与交换器绑定的队列中，规则简单，速度快，适合用来广播消息

direct：相比fanout来说非常严格，只有RoutingKey和BindingKey完全匹配才会被转发到响应的队列中，direct通常用来处理优先级任务，通过指定的键将优先级高的消息发送到指定队列

topic：灵活性很高，如果我们的RoutingKey是用 `.`号分隔的字符串，例如`com.stu.abc`，那么在交换器中可以指定响应的规则：`*`表示只匹配一位的通配符，`#`，可以匹配0个或者多个位(这里所说的位是被`.`分隔出来的，就像上面所给出的字符串，com就是表示可以通配的一位。com.*.abc表示转发com开头 abc结尾的消息到指定队列，com.# 表示抓发以com开头的所有消息到指定队列)

header：headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ 会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。
