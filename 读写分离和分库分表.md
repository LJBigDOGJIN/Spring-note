#### 什么是读写分离？

通过字面意思来看，读写分离就是将读操作和写操作分离开来，在数据库中就是将读操作和写操作分别分配到不同的数据库中。

通常来说mysql会有好几个服务器，将这些分为主服务器和从服务器，一般主服务器用来写，从服务器用来读。

![image-20240909171039380](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240909171039380.png)

这种情况下又涉及到一个数据一致性的问题，当主服务写完之后要把数据更新到从服务器，也就是我们常说的**主从复制**

#### 如何实现读写分离？

- 部署一个主服务器和多个从服务器
- 将主服务的数据更新到从服务器
- 主服务器写，从服务器读

在项目中实现方式有两种：代理方式和第三方插件

- 代理方式

  ![image-20240909172028697](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240909172028697.png)

我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。

提供类似功能的中间件有 **MySQL Router**（官方， MySQL Proxy 的替代方案）、**Atlas**（基于 MySQL Proxy）、**MaxScale**、**MyCat**。

关于 MySQL Router 多提一点：在 MySQL 8.2 的版本中，MySQL Router 能自动分辨对数据库读写/操作并把这些操作路由到正确的实例上。这是一项有价值的功能，可以优化数据库性能和可扩展性，而无需在应用程序中进行任何更改。

- 第三方插件

在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。

这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 `sharding-jdbc` ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。

#### 主从复制的原理是什么？

主要依靠MySQL的binary log（二进制日志文件）binlog记录了数据库中数据的所有变化（所有的DDL和DML语句），通过执行binlog文件可以将数据从主服务器上同步到从服务器上。

![image-20240910185205150](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240910185205150.png)

1. 主库将数据变化写入binlog
2. 从库连接主库
3. 从库I/O线程向主库请求数据，
4. 主库创建一个binlog dump线程将binlog数据发送给从库
5. i/o线程接收数据后将数据写到relay log中
6. 从库的SQL线程执行relay log中的sql，从而将数据同步到从库

> 一般看到binlog就会想到主从复制，但是binlog出了主从复制外，还能实现数据恢复

**MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。**

#### 如何避免主从主从延迟？

首先来看一下什么叫主从同步延迟。当我们主服务器上的数据发生变化时要将数据同步到从服务器库上，我们知道从库主要是用来读取数据，但是当我们在同步数据的过程中，如果有人从从库中读取了一条或几条数据，那么因为我们的数据还未从主服务器同步完成，所以读取的还是旧数据，就造成了数据不一致的问题，而导致这一问题的原因就是主从延迟。

怎么避免这个，在一个博主上看的两种方法，简单说一下，还没实操过。

**第一种就是将从库过期的数据的读取请求强制路由到主服务器上，这样就能直接读取到最新的数据**

第二种就是延迟读取，在数据同步完成后，从库在进行数据的查询，不过这种方式好像不太建议使用，因为这种确实没什么用哈哈。

#### 主从延迟是怎样产生的，什么情况下会出现主从延迟，如何尽量减少主从延迟？

主从延迟是由于从库的数据落后于主库的数据，造成这种结果的原因主要有以下两点：

1. 从库I/O线程接收binlog数据的速度跟不上主库往binlog中写的速度，导致从库的relay log中的数据落后于binlog
2. 从库SQL线程执行relay的速度跟不上I/O线程接收binlog的速度

与主从同步有关的时间点主要有 3 个：

1. 主库执行完一个事务，写入 binlog，将这个时刻记为 T1；
2. 从库 I/O 线程接收到 binlog 并写入 relay log 的时刻记为 T2；
3. 从库 SQL 线程读取 relay log 同步数据本地的时刻记为 T3。

结合我们上面讲到的主从复制原理，可以得出：

- T2 和 T1 的差值反映了从库 I/O 线程的性能和网络传输的效率，这个差值越小说明从库 I/O 线程的性能和网络传输效率越高。
- T3 和 T2 的差值反映了从库 SQL 线程执行的速度，这个差值越小，说明从库 SQL 线程执行速度越快。

那什么情况下会出现出从延迟呢？这里列举几种常见的情况：

1.**从库机器性能比主库差**：从库接收 binlog 并写入 relay log 以及执行 SQL 语句的速度会比较慢（也就是 T2-T1 和 T3-T2 的值会较大），进而导致延迟。解决方法是选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化，比如调整参数、增加缓存、使用 SSD 等。

2.**从库处理的读请求过多**：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率（也就是 T2-T1 和 T3-T2 的值会较大，和前一种情况类似）。解决方法是引入缓存（推荐）、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力，比如将 binlog 接入到 Hadoop、Elasticsearch 等系统中。

3.**大事务**：运行时间比较长，长时间未提交的事务就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是避免大批量修改数据，尽量分批进行。类似的情况还有执行时间较长的慢 SQL ，实际项目遇到慢 SQL 应该进行优化。

4.**从库太多**：主库需要将 binlog 同步到所有的从库，如果从库数量太多，会增加同步的时间和开销（也就是 T2-T1 的值会比较大，但这里是因为主库同步压力大导致的）。解决方案是减少从库的数量，或者将从库分为不同的层级，让上层的从库再同步给下层的从库，减少主库的压力。

5.**网络延迟**：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 binlog 的传输效率，导致从库延迟。解决方法是优化网络环境，比如提升带宽、降低延迟、增加稳定性等。

6.**单线程复制**：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了 **多线程复制**，MySQL 5.7 还进一步完善了多线程复制。

7.**复制模式**：MySQL 默认的复制是异步的，必然会存在延迟问题。全同步复制不存在延迟问题，但性能太差了。半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟（还是有一定程度的延迟）。MySQL 5.5 开始，MySQL 以插件的形式支持 **semi-sync 半同步复制**。并且，MySQL 5.7 引入了 **增强半同步复制** 。

### 分库分表

分库分表主要用来解决数据库中的存储压力，此处后面再说，先不急着看。